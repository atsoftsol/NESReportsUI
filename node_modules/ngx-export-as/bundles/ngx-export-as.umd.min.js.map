{"version":3,"sources":["ng://ngx-export-as/lib/export-as.service.ts","ng://ngx-export-as/lib/export-as.module.ts"],"names":["window","html2canvas","ExportAsService","prototype","get","config","func","type","toUpperCase","this","Observable","create","observer","error","save","fileName","download","subscribe","contentToBlob","content","arr","split","mime","match","bstr","atob","n","length","u8arr","Uint8Array","charCodeAt","next","Blob","complete","removeFileTypeFromBase64","fileContent","Symbol","replace","addFileTypeToBase64","fileMime","downloadFromDataURL","dataURL","_this","blob","downloadFromBlob","element","document","createElement","url","URL","createObjectURL","setAttribute","style","display","body","appendChild","href","click","removeChild","getPDF","jspdf","jsPDF","getElementById","elementId","addHTML","output","getPNG","options","then","canvas","imgData","toDataURL","err","getCSV","csv","querySelectorAll","forEach","rowElement","index","row","col","colIndex","push","innerText","join","csvContent","btoa","getTXT","nameFrags","getXLS","ws3","XLSX.utils","table_to_sheet","wb","book_new","book_append_sheet","xlsContent","XLSX.write","getXLSX","getDOCX","outerHTML","converted","htmlDocx.asBlob","reader_1","FileReader","onloadend","base64data","result","readAsDataURL","getDOC","getJSON","data","headers","table","rows","cells","innerHTML","toLowerCase","i","tableRow","rowData","j","jsonString","JSON","stringify","dataStr","getXML","xml","tritem","getElementsByTagName","celldata","textContent","m","base64","Injectable","args","providedIn","ExportAsModule","NgModule","providers"],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\n\nimport { ExportAsConfig } from './export-as-config.model';\n\nimport html2canvas from 'html2canvas';\nimport * as jsPDF from 'jspdf';\nimport * as XLSX from 'xlsx';\nimport * as htmlDocx from 'html-docx-js/dist/html-docx';\n\nwindow['html2canvas'] = html2canvas;\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ExportAsService {\n\n  constructor() { }\n\n  get(config: ExportAsConfig): Observable<string | null> {\n    const func = 'get' + config.type.toUpperCase();\n    if (this[func]) {\n      return this[func](config);\n    }\n\n    return Observable.create((observer) => { observer.error('Export type is not supported.'); });\n  }\n\n  save(config: ExportAsConfig, fileName: string): void {\n    config.download = true;\n    config.fileName = fileName + '.' + config.type;\n    this.get(config).subscribe();\n  }\n\n  contentToBlob(content: string): Observable<Blob> {\n    return Observable.create((observer) => {\n      const arr = content.split(','), mime = arr[0].match(/:(.*?);/)[1],\n        bstr = atob(arr[1]);\n      let n = bstr.length;\n      const u8arr = new Uint8Array(n);\n      while (n--) {\n        u8arr[n] = bstr.charCodeAt(n);\n      }\n      observer.next(new Blob([u8arr], { type: mime }));\n      observer.complete();\n    });\n  }\n\n  removeFileTypeFromBase64(fileContent: string): string {\n    const re = /^data:[^]*;base64,/g;\n    const newContent: string = re[Symbol.replace](fileContent, '');\n    return newContent;\n  }\n\n  addFileTypeToBase64(fileContent: string, fileMime: string): string {\n    return `data:${fileMime};base64,${fileContent}`;\n  }\n\n  downloadFromDataURL(fileName: string, dataURL: string): void {\n    this.contentToBlob(dataURL).subscribe(blob => {\n      this.downloadFromBlob(blob, fileName);\n    });\n  }\n\n  downloadFromBlob(blob: Blob, fileName: string) {\n    const element = document.createElement('a');\n    const url = window.URL.createObjectURL(blob);\n    element.setAttribute('download', fileName);\n    element.style.display = 'none';\n    document.body.appendChild(element);\n    element.href = url;\n    element.click();\n    document.body.removeChild(element);\n  }\n\n  private getPDF(config: ExportAsConfig): Observable<string | null> {\n    return Observable.create((observer) => {\n      const jspdf = new jsPDF();\n      const element: HTMLElement = document.getElementById(config.elementId);\n      jspdf.addHTML(element, function () {\n        if (config.download) {\n          jspdf.save(config.fileName);\n          observer.next();\n        } else {\n          observer.next(jspdf.output('datauristring'));\n        }\n        observer.complete();\n      });\n    });\n  }\n\n  private getPNG(config: ExportAsConfig): Observable<string | null> {\n    return Observable.create((observer) => {\n      const element: HTMLElement = document.getElementById(config.elementId);\n      html2canvas(element, config.options).then((canvas) => {\n        const imgData = canvas.toDataURL('image/PNG');\n        if (config.type === 'png' && config.download) {\n          this.downloadFromDataURL(config.fileName, imgData);\n          observer.next();\n        } else {\n          observer.next(imgData);\n        }\n        observer.complete();\n      }, err => {\n        observer.error(err);\n      });\n    });\n  }\n\n  private getCSV(config: ExportAsConfig): Observable<string | null> {\n    return Observable.create((observer) => {\n      const element: HTMLElement = document.getElementById(config.elementId);\n      const csv = [];\n      const rows: any = element.querySelectorAll('table tr');\n      rows.forEach((rowElement, index: number) => {\n        const row = [];\n        const cols = rowElement.querySelectorAll('td, th');\n        cols.forEach((col, colIndex: number) => {\n          row.push(col.innerText);\n        });\n        csv.push(row.join(','));\n      });\n      const csvContent = 'data:text/csv;base64,' + btoa(csv.join('\\n'));\n      if (config.download) {\n        this.downloadFromDataURL(config.fileName, csvContent);\n        observer.next();\n      } else {\n        observer.next(csvContent);\n      }\n      observer.complete();\n    });\n  }\n\n  private getTXT(config: ExportAsConfig): Observable<string | null> {\n    const nameFrags = config.fileName.split('.');\n    config.fileName = `${nameFrags[0]}.txt`;\n    return this.getCSV(config);\n  }\n\n  private getXLS(config: ExportAsConfig): Observable<string | null> {\n    return Observable.create((observer) => {\n\n      const element: HTMLElement = document.getElementById(config.elementId);\n      const ws3 = XLSX.utils.table_to_sheet(element, config.options);\n      const wb = XLSX.utils.book_new();\n      XLSX.utils.book_append_sheet(wb, ws3, config.fileName);\n      const out = XLSX.write(wb, { type: 'base64' });\n      const xlsContent = 'data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,' + out;\n      if (config.download) {\n        this.downloadFromDataURL(config.fileName, xlsContent);\n        observer.next();\n      } else {\n        observer.next(xlsContent);\n      }\n      observer.complete();\n    });\n  }\n\n  private getXLSX(config: ExportAsConfig): Observable<string | null> {\n    return this.getXLS(config);\n  }\n\n  private getDOCX(config: ExportAsConfig): Observable<string | null> {\n    return Observable.create((observer) => {\n      const contentDocument: string = document.getElementById(config.elementId).outerHTML;\n      const content = '<!DOCTYPE html>' + contentDocument;\n      const converted = htmlDocx.asBlob(content, config.options);\n      if (config.download) {\n        this.downloadFromBlob(converted, config.fileName);\n        observer.next();\n        observer.complete();\n      } else {\n        const reader = new FileReader();\n        reader.onloadend = () => {\n          const base64data = reader.result;\n          observer.next(base64data);\n          observer.complete();\n        };\n        reader.readAsDataURL(converted);\n      }\n    });\n  }\n\n  private getDOC(config: ExportAsConfig): Observable<string | null> {\n    return this.getDOCX(config);\n  }\n\n  private getJSON(config: ExportAsConfig): Observable<any[] | null> {\n    return Observable.create((observer) => {\n      const data = []; // first row needs to be headers\n      const headers = [];\n      const table = <HTMLTableElement>document.getElementById(config.elementId);\n      for (let index = 0; index < table.rows[0].cells.length; index++) {\n        headers[index] = table.rows[0].cells[index].innerHTML.toLowerCase().replace(/ /gi, '');\n      }\n      // go through cells\n      for (let i = 1; i < table.rows.length; i++) {\n        const tableRow = table.rows[i]; const rowData = {};\n        for (let j = 0; j < tableRow.cells.length; j++) {\n          rowData[headers[j]] = tableRow.cells[j].innerHTML;\n        }\n        data.push(rowData);\n      }\n      const jsonString = JSON.stringify(data);\n      const jsonBase64 = btoa(jsonString);\n      const dataStr = 'data:text/json;base64,' + jsonBase64;\n      if (config.download) {\n        this.downloadFromDataURL(config.fileName, dataStr);\n        observer.next();\n      } else {\n        observer.next(data);\n      }\n      observer.complete();\n    });\n  }\n\n  private getXML(config: ExportAsConfig): Observable<string | null> {\n    return Observable.create((observer) => {\n      let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?><Root><Classes>';\n      const tritem = document.getElementById(config.elementId).getElementsByTagName('tr');\n      for (let i = 0; i < tritem.length; i++) {\n        const celldata = tritem[i];\n        if (celldata.cells.length > 0) {\n          xml += '<Class name=\"' + celldata.cells[0].textContent + '\">\\n';\n          for (let m = 1; m < celldata.cells.length; ++m) {\n            xml += '\\t<data>' + celldata.cells[m].textContent + '</data>\\n';\n          }\n          xml += '</Class>\\n';\n        }\n      }\n      xml += '</Classes></Root>';\n      const base64 = 'data:text/xml;base64,' + btoa(xml);\n      if (config.download) {\n        this.downloadFromDataURL(config.fileName, base64);\n        observer.next();\n      } else {\n        observer.next(base64);\n      }\n      observer.complete();\n    });\n  }\n\n}\n","/**\n * angular imports\n */\nimport { NgModule } from '@angular/core';\n\n/**\n * my imports\n */\n\nimport { ExportAsService } from './export-as.service';\n\n@NgModule({\n  providers: [ExportAsService],\n})\nexport class ExportAsModule { }\n\n\n"]}